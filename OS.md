# 1. 운영체제
## 1.1 프로세스와 스레드의 차이?
```
프로세스는 OS로 부터 자원을 할당받고, 스레드는 프로세스로 부터 자원을 할당받습니다. 
하나의 프로세스 안에서 스택을 제외한 메모리 공간을 공유하며 여러 스레드 생성이 가능합니다.

공유 메모리 공간: 코드/데이터/힙
개별 메모리 공간: 스택

+a
프로세스를 다수의 멀티 스레드로 구성하면, Context-switching시 통신의 부담이 적어, 응답시간이 빠르고,
자원을 공유하는 만큼 자원을 아낄 수 있습니다. 하지만 자원을 공유하기 때문에 동기화 문제가 발생하며, 
스레드는 OS가 관리해 주지 않기 때문에 프로그래머가 안정적으로 프로그래밍해야 한다는 단점이 있습니다.
```
## 1.2 교착상태란 무엇이며, 교착상태가 발생하기 위한 조건?
```
교착상태는 둘 이상의 프로세스들이 자원을 점유한 상태에서, 서로 다른 프로세스가 점유한 자원을
무한히 기다리고 있는 상태입니다. 교착상태가 발생하기 위해서는 상호배제, 점유 대기, 비선점, 순환 대기
4가지 조건이 모두 만족되어야합니다.

+a
‘상호배제’:      한 자원을 한번에 한 프로세스만이 사용할 수 있음을 말합니다.
‘점유 및 대기’:  한 프로세스가 하나 이상의 리소스를 점유하고 있으면서 다른 프로세사가 가지고 있는 리소스를 기다리는 상태를 말합니다.
‘비선점’:        프로세스가 작업을 마치고 자발적으로 자원을 반환할 때까지 기다리는 것을 말합니다.
‘환형 대기’:     점유 및 대기 상태에서 프로세서들이 서로 기다리고 있는 상태를 말합니다.
```
## 1.3 교착상태의 해결 방법은?
```
교착상태를 해결하는 방법에는 예방, 회피, 탐지 및 회복 3가지가 있습니다.
‘예방’은, 자원을 할당하는 구조적 측면에서 교착상태가 발생할 수 있는 4가지 조건을 만족시키지 않게 하는 것을 말합니다.
‘회피’는 자원을 할당할 때, 교착상태가 발생할 가능성이 있으면 자원을 할당하지 않는 것을 말합니다. 대표적으로 은행원 알고리즘이 있습니다.
‘탐지 및 회복’은 교착상태가 발생할 수 있도록 두고, 발생할 경우 찾아내 회복시키는 것입니다. 회복을 위해서 한 프로세스를 강제로 종료하는 방법을 사용할 수 있습니다.

+a
은행원 알고리즘이란 안정상태와 불안정상태를 구분해 안정상태를 유지할 수 있을 때에만 자원을 할당해주는 
알고리즘입니다. 안정상태는 각 프로세스가 요구한 자원의 양이 소지한 자원의 양을 넘지 않도록 
배정해 줄 수 있는 순서가 존재하는 상태를 말합니다. 즉, 은행원 알고리즘을 적용하기 위해서는 
각 프로세스들이 요구할 자원의 양, 현재 프로세스가 사용중인 자원의 양, 가용한 자원의 양을 
알 수 있어야 합니다.
```
## 1.4 뮤텍스와 세마포어에 대해 설명해 보세요.
```
뮤텍스와 세마포어는 Critical Section에 여러 프로세스가 동시에 접근해 발생하는 문제를 방지하기 위한 
알고리즘입니다. 
뮤텍스는 Critical Section 하나의 프로세스 또는 스레드가 접근할 수 있도록 하나의 key가 존재하며, 
세마포어는 key의 개수를 정해, key의 개수만큼 접근할 수 있게 만들 수 있습니다.

+a
Ciritical Section => 여러 스레드/프로세스가 접근 가능한 공유자원
```
## 1.5 컨텍스트 스위칭이란?
```
여러 프로그램을 동시에 실행하고 있는 것처럼 보이기 위해, 
CPU는 다수의 프로세스들을 일정시간 처리 후에 교체하는 방식을 활용합니다. 
이때 다른 프로세스로 교체하기 위해, 현재 실행 중이던 프로세스의 상태를 저장하고, 
다음에 실행할 프로세스의 상태를 로드하는 작업을 컨텍스트 스위칭이라고 합니다.
```
## 1.6 프로세스 혹은 스레드의 동기화란 무엇인가요?
```
프로세스 동기화란 하나의 자원을 한 순간에 하나의 프로세스만이 이용하도록 제어하는 것이고, 
스레드의 동기화란 하나의 코드블록, 메소드를 한순간에 하나의 스레드만이 이용하도록 보장하는 것입니다. 
동기화의 목표는 데이터의 정합성으로 프로그램이 원하는 결과를 정상적으로 출력하는 것을 보장하기 위한 
하나의 기술입니다.
```
## 1.7 사용자 수준의 스레드와 커널 수준의 스레드의 차이는 무엇인가요?
```
생성의 주체에 따라 구분이 됩니다. 
사용자 수준의 스레드는 사용자가 구현해 사용하는 스레드이고, 
모든 동작이 사용자 영역에서 이루어지기 때문에, 커널이 관리하지 못합니다. 
따라서 사용자가 직접 스레드 간 보호 매커니즘을 작성해야합니다.

커널 수준의 스레드는 커널이 관리하는 스레드입니다. 
커널이 직접 스케줄링하고 실행하기 때문에, 많은 지원을 받을 수 있습니다. 
또한, 커널이 각 스레드들을 개별적으로 관리하므로, 
동일한 프로세스의 스레드 중 하나가 대기 상태가 되어도, 다른 스레드를 실행시킬 수 있습니다.
```
## 1.8 CPU 스케줄링이란 무엇인가요?
```
CPU 스케줄링의 목적은 CPU의 활용도를 최대한 높이기 위함 입니다. 
한 프로세스가 Interrupt 또는 I/O 작업로 인해 일시적으로 CPU를 사용하지 않는 시간이 발생할 수 있는데,
이때, 다른 프로세스에게 CPU를 넘겨 활용도를 높일 수 있습니다. (Idle 시간을 줄일 수 있습니다.) 
```
## 1.9 CPU 스케쥴링 방법에는 대표적으로 어떤 것들이 있나요?
```
크게 선점 스케줄링과 비선점 스케줄링으로 구분됩니다.
선점 스케줄링은 CPU를 한 프로세스가 점유하고 있을 때, 우선순위가 높은 프로세스가 강제로 빼앗을 수 있습니다.

1. Shortest Remaining Time: 짧은 시간 순서대로 수행됩니다.
2. Round-Robin: 각 프로세스가 동일한 점유 시간을 할당 받고 FIFO에 의해 수행됩니다.
3. Multi-level Queue: Ready 큐를 여러 개 사용해, 큐와 큐사이, 큐안에서 각각의 정책을 사용합니다.
4. 다단계 피드백 큐: 다단계 큐와 비슷하고, 프로세스들이 큐를 이동할 수 있습니다.

비선점 스케줄링은 선점과 반대로 강제로 빼앗지 못합니다.
1. Highest response ratio next: 수행시간과 대기시간을 고려해 우선순위를 정하는 기법입니다.
2. Shortest Job First: 큐 안에 있는 프로세스 중 수행시간이 짧은 것을 먼저 수행하는 기법입니다.
3. Priority: 우선순위를 정적, 동적으로 부여해 우선순위에 맞추어 처리하는 기법
4. Deadline: 작업을 명시된 시간이나 기한 내에 완료하도록 계획하는 기법입니다.
5. FIFO: Ready 큐에 도착한 순서대로 처리하는 단순한 기법입니다.
```
## 1.10 동기와 비동기, 블로킹과 논블로킹의 차이는 무엇인가요?
```
동기:   한 작업이 완료되어야 다음 작업을 시작하는 방식입니다.
비동기: 한 작업이 완료되기 전에 다른 작업을 수행할 수 있는 방식입니다.

따라서 동기식은 구성이 단순하지만, 멀티 태스킹이 불가능 하다는 단점이 있습니다.
비동기식은 멀티 태스킹이 가능하지만, 요청량에 따라 부하가 발생할 수 있으며, ciritical section과 같은
부분을 프로그래머가 처리해 주어야 하기 때문에 구현이 복잡합니다.

블로킹:  요청한 작업을 마칠 때까지 계속 대기하는 방식입니다.
논블로킹:요청한 작업이 즉시 처리될 수 없으면 즉시 return 하는 방식입니다.

따라서 호출된 함수가 바로 return해서 제어권을 넘겨주고, 
호출한 함수가 다른 일을 할 기회를 주는 것이 논블로킹 방식,
자신의 작업을 모두 마쳐야 제어권을 넘겨주는 것이 블로킹 방식입니다.

```
