# 3. Database
## 3.1 Basic
### 3.1.1 정규화에 대해서 설명해주세요.
```
데이터의 무결성과 안정성 높이기 위해, 데이터를 구조화시키는 것을 말합니다. 
1단계는 원자 값 아닌 속성을 분해해 원자 값으로 변경합니다. (도메인이 원자값 )
2단계와 3단계는 함수적 종속과 이행 함수적 종속을 제거하는 단계입니다. (부분적 함수 종속 제거)
										(이행적 함수 종속 제거)
4단계는 결정자 중 후보키가 아니면 제거합니다.
5단계는 다치 종속제거
6단계는 조인 종속성 이용
앞선 6단계를 거쳐 최종 형태를 만드는 것이 정규화 과정입니다.	

+a
완전 함수적 종속 관계: 합성키를 모두 사용해야만 식별할 수 있는 관계
부분 함수적 종속 관계: 합성키 중 일부 키를 사용해서도 식별할 수 있는 관계
이행 함수적 종속 관계: X와 Y가 종속관계이고, Y와 Z가 종속관계가 있어 X와 Z가 종속관계가 성립하는 경우
```
### 3.1.2 JOIN에 대해서 설맹해 주세요.
```
동일한 키속성을 가진 두개의 테이블을 합치는 연산입니다. 대표적으로 inner 조인, outer 조인의 left, right가 있습니다. 
A와 B를 조인할 때,
Inner 조인의 결과는 A와 B의 교집합입니다.
Left 조인은 A값의 전체와, A의 key값과 B의 key값이 같은 부분 값을 추가해 리턴합니다. 없는 부분은 NULL 값을 가집니다.
Right 조인은 Left와 반대로 B값의 전체와 key값이 동일한 부분의 값을 추가하고, 역시 없는 부분은 NULL로 설정됩니다.
```
### 3.1.3 내부조인과 외부 조인의 차이는?
```
내부 조인은 두 테이블의 공통적인 부분만 가져오는 것이고, 
외부 조인은 한테이블에서는 전체 값을 가져오고, 데이터가 존재하지 않는 key값에 대해서는 기본적으로 NULL 값을 부여한다는 차이가 있습니다.
```
### 3.1.4 파티셔닝과 샤딩에 대해 설명해 주세요.
```
DB의 서비스 크기 증가에 따라 성능 등의 이유로 DB를 여러 개로 나누어 분산시키기 위한 기술입니다.
파티셔닝은 큰 테이블이나 인덱스를 관리하기 쉬운 크기로 분리하는 방법입니다. Availabillity, Manageability, performance 측면에서 효율적입니다. 하지만, table간 join 비용이 증가하고, 테이블과 인덱스를 별도로 나눌 수 없다는 단점이 있습니다.
방법으로는 Horizontal Partitioning, Vertical Partitioning 이 있습니다.
샤딩은 Horizontal Partitioning의 일종으로, 물리적으로 다른 DB에 데이터를 수평 분할하는 방식이다. 예를 들어 ‘주민’ 테이블이 여러 DB에 있을 때, 양천구는 A DB에, 강서구는 B DB에 저장하는 방식이다. 하나의 트랜잭션에서 두개 이상의 샤드에 접근 할 수 없는 등의 한계가 있습니다.
```
### 3.1.5 ORM이란 무엇인가요?
```
* Object-Relational Mapping
객체와 관계형 DB의 데이터를 자동으로 매핑해주는 것을 말합니다. 객체 지향 프로그래밍은 클래스를 사용하고, 관계형 DB는 테이블을 사용합니다. 
이때, 객체 모델과 관계형 모델 간에 불일치하는 부분이 존재할 수 있는데, ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성해 문제를 해결합니다.

+a
Spring framework가 곧 ORM 개발 방식
```
### 3.1.6 No SQL이란 무엇인가요?
```
Not Only SQL의 약자로 기존 RDBMs 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미하며, 
관계형 데이터 베이스의 한계를 극복하기 위한 데이터 저장소의 새로운 형태로, 수평적 확장성을 갖고 있다. 
문서, 그래프, 키 값, 인 메모리, 검색을 포함해 다양한 데이터 모델을 사용한다. 
RDBMS가 클라이언트/서버 환경에 맞는 데이터 저장기술이라면, NoSQL은 클라우드 환경에 맞는 저장 기술입니다. 

+a
종류: key-value DB, Wide Columnar DB, KDoument DB, Graph DB
```
### 3.1.7 스키마란 무엇인가요?
```
DB의 구조와 제약조건에 관해 전반적인 명세를 기술한 것입니다. 여기에는 속성, 개체 사의 관계 및 정의 그리고 여러가지 제약 조건들이 포함됩니다. 
변하지 않는 특성이 있고, 개념, 내부, 외부 스키마로 구분할 수 있습니다.
‘개념 스키마’는 전체적인 뷰를 의미합니다. 즉, DB 전체를 기술한 것과 동일하며 1개만 존재합니다.
‘내부 스키마’는 물리적인 저장장치 입장에서 데이터가 저장되는 방법을 기술 한 것입니다. 즉, 개념 스키마를 실제 디스크에 저장하기 위해, 내부 레코드 형식, 순서 인덱스 유무 등에 관한 것입니다.
‘외부 스키마’는 사용자나 응용 프로그래머가 개인에 입장에서 필요한 구조를 정의한 것을 의미합니다. 실제 데이터들을 어떤 형식, 구조, 배치를 통해 사용자에게 보여줄 것인가에 관한 것입니다.
```
## 3.2 인덱스
### 3.2.1 인덱스란 무엇인가요? 어떻게 동작하나요?
```
추가 적인 쓰기 작업과 저장 공간을 활용해 DB의 검색 속도를 향상시키기 위한 자료구조입니다. 
인덱스는 대표적으로 해시 테이블과 B+ Tree를 활용해 구현할 수 있습니다.
해시 테이블을 사용하면 key-value 쌍으로 데이터를 저장해, key값을 이용해 고유한 index를 생성하며, 그 index에서 저장된 값을 가져오는 방식을 사용합니다.
B+ Tree를 사용하면, 리프노드만 인덱스와 함께 데이터를 가지고 있고, 나머지 노드들은 데이터를 위한 인덱스만 가지고 있는 형태로 구현이 됩니다. 인덱스가 주어지면, 루트부터 적정한 리프노드로 탐색해가 값을 가져옵니다.
```
### 3.2.2 인덱스의 알고리즘에는 어떤 것들이 있나요?
```
해시 테이블, B 트리, B+ 트리 등의 자료구조를 활용해 구현할 수 있습니다.
```
### 3.2.3 Table Full Scan과 Index Range Scan을 설명해주세요.
```
Table Full Scan은 해당 테이블에 전체 블록을 읽어 사용자가 원하는 데이터를 찾는 방식입니다. 
Index Range Scan은 인덱스를 이용해 데이터를 일정부분 읽어서, 데이터가 디스크 상에 저장된 위치를 알아내 찾는 방식입니다.

Table Full Scan에 경우 읽고자 하는 데이터의 블록을 Multi Block I/O로 읽기 때문에 프로세스가 데이터를 바로 처리할 수 있으나, 
Index의 경우 Single Block I/O로 데이터를 읽습니다. 
그렇기 때문에 데이터를 모두 읽는 I/O Call이 끝날 때까지 정작 프로세스는 대기 상태에 들어가기 때문에 비효율적인 상태가 됩니다.
```
## 3.3 트랜잭션
### 3.3.1 트랜잭션이란 무엇인가요? 4가지 원칙을 포함해서 설명해 주세요.
```
데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위를 뜻합니다. 
트랜잭션이 만족해야하는 특성으로 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 영구성(Durability) 4가지가 있습니다.
'원자성'은 트랜잭션의 내용이 DB 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것입니다.
'일관성'은 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것입니다.
'독립성'은 둘 이상의 트랜잭션이 동시에 실행될 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션에게 영향을 미치지 않아야함을 말합니다.
'지속성'은 트랜잭션이 성공적으로 완료된 경우, 결과가 영구적으로 반영되어야 한다는 것입니다.
```
### 3.3.2 트랜잭션의 격리 수준과 각 수준에서 발생할 수 있는 문제들에 대해 말해 보세요.
```
트랜잭션의 격리 수준에는 낮은 순으로 
Read Uncommitted, Read Committed, Repetable Read, Serializable 이 있습니다.

발생할 수 있는 문제들은 
Dirty Read, Non-Retetable Read, Phantom Read 가 있습니다.

제일 낮은 격리 수준에서는 3가지 문제가 모두 발생하며, 한단계 높아질수록 말씀드린 순으로 문제가 발생하지 않습니다.
Dirty read는 커밋 되지 않은 변경 중인 데이터를 읽는 것을 의미합니다.
Non-Repetable Read는 하나의 트랜잭션이 진행되는 동안 동일한 select는 동일한 결과를 반환해야 하는데 그렇지 못한 상황이 발생한 경우입니다. (예를 들어 보석가게에서 손님이 처음 조회했을 때는 원석으로 나타나 원석을 가지고 진행하던 중, 가게 주인이 원석을 다이아로 바꾸면, 손님이 다시 조회를 했을 때 데이터가 갑자기 변해있는 상태입니다.)
Phantom Read는 중간에 데이터가 INSERT 되어 갑자기 보이지 않던 데이터가 보이는 경우를 말합니다. 이는 자신보다 늦게 시작한 트랜잭션이라면 커밋을 해도 이전 결과를 가져오게 처리했지만 insert에는 적용되지 않아 발생하는 문제입니다.
마지막 단계에서는 데이터의 정합성 문제가 발생하지 않습니다. 그만큼 Lock이 까다롭기 때문에 성능이 많이 떨어지게 됩니다.
```
### 3.3.3 공유 락과 베타 락의 차이는 무엇인가요?
```
공유 락은 데이터를 읽을 때 사용되는 락입니다. 이러한 공유 Lock은 공유 Lock끼리는 동시에 접근이 가능합니다. 
즉, 하나의 데이터를 여러 사용자가 동시에 읽을 수 있음을 의미합니다.
베타 락은 데이터를 변경하고자 할 때 사용합니다. 
트랜잭션이 완료될 때 까지 유지되며, 락이 해제 되기 전까지 다른 트랜잭션은 해당 데이터에 접근할 수 없습니다.
```
### 3.3.4 데이터베이스에서 데드락이란 무엇이며, 어떻게 발생할까요?
```
데이터베이스에서 데드락이란 여러개의 트랜잭션들이 실행을 하지 못하고 서로 무한정 기다리는 상태를 의미합니다.
데이터베이스는 트랜잭션들의 동시성을 제어하기 위해 Lock을 사용하는데,
이것이 데이터의 일관성은 유지시켜주지만, 부작용으로 데드락 상태를 발생시킬 수 있습니다.
```
### 3.3.5 데이터베이스의 교착상태 해결 방법?
```
예방 기법
		1. 각 트랜잭션이 실행되기 전 필요한 데이터를 모두 locking 해주는 것 (동시에 여러 트랜잭션을 사용하기 어려운 환경이됨)
회피 기법
		1. Wait-Die 방식
		2. Wound-Wait 방식
		3. 시산 스탬프 기법
		4. 낙관적 병행 제어 기법
```
